#!/usr/bin/env python3
"""
MIDI Configuration Script
Allows user to select MIDI input and output ports and saves configuration for later use.
"""

import mido
import json
import os
from typing import Dict, List, Optional

CONFIG_FILE = "midi_config.json"

def get_available_ports() -> Dict[str, List[str]]:
    """Get all available MIDI input and output ports"""
    try:
        input_ports = mido.get_input_names()
        output_ports = mido.get_output_names()
        return {
            "inputs": input_ports,
            "outputs": output_ports
        }
    except Exception as e:
        print(f"Error getting MIDI ports: {e}")
        return {"inputs": [], "outputs": []}

def display_ports(ports: Dict[str, List[str]]) -> None:
    """Display available MIDI ports in a nice format"""
    print("\n" + "="*60)
    print("AVAILABLE MIDI PORTS")
    print("="*60)
    
    print("\nüéπ MIDI INPUT PORTS:")
    if ports["inputs"]:
        for i, port in enumerate(ports["inputs"]):
            print(f"  {i + 1}: {port}")
    else:
        print("  No MIDI input ports found")
    
    print("\nüéõÔ∏è  MIDI OUTPUT PORTS:")
    if ports["outputs"]:
        for i, port in enumerate(ports["outputs"]):
            print(f"  {i + 1}: {port}")
    else:
        print("  No MIDI output ports found")
    
    print("\n" + "="*60)

def get_user_choice(prompt: str, options: List[str], allow_none: bool = False) -> Optional[str]:
    """Get user's choice from a list of options"""
    if not options:
        print("No options available!")
        return None
    
    while True:
        try:
            print(f"\n{prompt}")
            for i, option in enumerate(options):
                print(f"  {i + 1}: {option}")
            
            if allow_none:
                print(f"  0: Skip/None")
            
            choice = input(f"\nEnter your choice (1-{len(options)}{'or 0' if allow_none else ''}): ").strip()
            
            if allow_none and choice == "0":
                return None
            
            choice_num = int(choice)
            if 1 <= choice_num <= len(options):
                return options[choice_num - 1]
            else:
                print(f"Please enter a number between 1 and {len(options)}")
                
        except ValueError:
            print("Please enter a valid number")
        except KeyboardInterrupt:
            print("\nOperation cancelled by user")
            return None

def test_ports(input_port: str, output_port: Optional[str]) -> bool:
    """Test if the selected ports work"""
    print(f"\nüîß Testing MIDI ports...")
    
    # Test input port
    try:
        with mido.open_input(input_port) as inport:
            print(f"‚úÖ Input port '{input_port}' - OK")
    except Exception as e:
        print(f"‚ùå Input port '{input_port}' - ERROR: {e}")
        return False
    
    # Test output port (if selected)
    if output_port:
        try:
            with mido.open_output(output_port) as outport:
                print(f"‚úÖ Output port '{output_port}' - OK")
                
                # Send a test message (CC 1, value 0) to make sure it works
                test_msg = mido.Message('control_change', channel=0, control=1, value=0)
                outport.send(test_msg)
                print("‚úÖ Test MIDI message sent successfully")
                
        except Exception as e:
            print(f"‚ùå Output port '{output_port}' - ERROR: {e}")
            return False
    else:
        print("‚ö†Ô∏è  No output port selected - LED feedback will be disabled")
    
    return True

def save_config(input_port: str, output_port: Optional[str]) -> bool:
    """Save MIDI configuration to file"""
    config = {
        "midi_input_port": input_port,
        "midi_output_port": output_port,
        "created_at": str(mido.get_input_names()),  # Store available ports for reference
        "note": "Generated by MIDI Configuration Script"
    }
    
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        print(f"‚úÖ Configuration saved to {CONFIG_FILE}")
        return True
    except Exception as e:
        print(f"‚ùå Error saving configuration: {e}")
        return False

def load_existing_config() -> Optional[Dict]:
    """Load existing configuration if it exists"""
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading existing config: {e}")
    return None

def main():
    """Main configuration flow"""
    print("üéµ MIDI Controller Configuration Tool")
    print("This tool will help you select the correct MIDI ports for your controller.")
    
    # Check for existing configuration
    existing_config = load_existing_config()
    if existing_config:
        print(f"\nüìÅ Found existing configuration:")
        print(f"   Input:  {existing_config.get('midi_input_port', 'None')}")
        print(f"   Output: {existing_config.get('midi_output_port', 'None')}")
        
        reconfigure = input("\nDo you want to reconfigure? (y/N): ").strip().lower()
        if reconfigure not in ['y', 'yes']:
            print("Using existing configuration. Run again with 'y' to reconfigure.")
            return
    
    # Get available ports
    ports = get_available_ports()
    
    if not ports["inputs"]:
        print("‚ùå No MIDI input ports found! Make sure your MIDI controller is connected.")
        return
    
    # Display all available ports
    display_ports(ports)
    
    # Get user's input port selection
    input_port = get_user_choice(
        "üéπ Select MIDI INPUT port (for receiving button/knob data):",
        ports["inputs"]
    )
    
    if not input_port:
        print("‚ùå No input port selected. Cannot continue.")
        return
    
    # Get user's output port selection
    output_port = None
    if ports["outputs"]:
        output_port = get_user_choice(
            "üéõÔ∏è  Select MIDI OUTPUT port (for LED feedback):",
            ports["outputs"],
            allow_none=True
        )
    
    # Test the selected ports
    if not test_ports(input_port, output_port):
        print("‚ùå Port testing failed. Please check your MIDI controller connection.")
        return
    
    # Save configuration
    if save_config(input_port, output_port):
        print("\nüéâ MIDI configuration complete!")
        print(f"   Input Port:  {input_port}")
        print(f"   Output Port: {output_port or 'None (LED feedback disabled)'}")
        print(f"\nYour configuration has been saved to '{CONFIG_FILE}'")
        print("Your Python scripts will now use these ports automatically.")
    else:
        print("‚ùå Failed to save configuration.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nConfiguration cancelled by user.")
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        print("Please check your MIDI controller connection and try again.")